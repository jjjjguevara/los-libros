/**
 * EPUB href parser for handling various navigation schemes
 *
 * Parses hrefs that may use special schemes generated by the server:
 * - position:N - Navigate to spine position N (0-indexed)
 * - page:N - Navigate to page N (1-indexed, converted to spine index)
 * - Regular hrefs - Standard file paths with optional hash fragments
 */

export type ParsedHref =
  | { type: 'position'; spineIndex: number }
  | { type: 'page'; pageNumber: number }
  | { type: 'standard'; href: string; fragment?: string };

/**
 * Parse an href string into a structured navigation target
 *
 * @param href - The href to parse (e.g., "position:5", "page:10", "chapter1.xhtml#section2")
 * @returns Parsed href object with navigation type and target
 *
 * @example
 * parseHref("position:5") // { type: 'position', spineIndex: 5 }
 * parseHref("page:10")    // { type: 'page', pageNumber: 10 }
 * parseHref("ch1.xhtml#s1") // { type: 'standard', href: 'ch1.xhtml', fragment: 's1' }
 */
export function parseHref(href: string): ParsedHref {
  // Handle empty or whitespace-only hrefs - default to first chapter
  if (!href || href.trim() === '') {
    console.warn('[href-parser] Empty href provided, defaulting to first chapter');
    return { type: 'position', spineIndex: 0 };
  }

  // Handle position:N scheme (0-indexed spine position)
  if (href.startsWith('position:')) {
    const position = parseInt(href.substring(9), 10);
    if (!isNaN(position) && position >= 0 && Number.isSafeInteger(position)) {
      return { type: 'position', spineIndex: position };
    }
    // Invalid position scheme - this shouldn't happen if server is working correctly
    // Default to first chapter rather than treating as standard href
    console.warn(`[href-parser] Invalid position scheme: ${href}, defaulting to first chapter`);
    return { type: 'position', spineIndex: 0 };
  }

  // Handle page:N scheme (1-indexed page number)
  if (href.startsWith('page:')) {
    const pageNum = parseInt(href.substring(5), 10);
    if (!isNaN(pageNum) && pageNum >= 1 && Number.isSafeInteger(pageNum)) {
      return { type: 'page', pageNumber: pageNum };
    }
    // Invalid page scheme - default to page 1
    console.warn(`[href-parser] Invalid page scheme: ${href}, defaulting to page 1`);
    return { type: 'page', pageNumber: 1 };
  }

  // Standard href - split into path and fragment
  const hashIndex = href.indexOf('#');
  if (hashIndex !== -1) {
    return {
      type: 'standard',
      href: href.substring(0, hashIndex),
      fragment: href.substring(hashIndex + 1),
    };
  }

  return { type: 'standard', href };
}

/**
 * Check if an href uses a special scheme (position: or page:)
 */
export function isSpecialScheme(href: string): boolean {
  return href.startsWith('position:') || href.startsWith('page:');
}

/**
 * Convert a page number to a spine index
 *
 * For EPUBs, page numbers typically map directly to spine indices (1-indexed page â†’ 0-indexed spine).
 * For PDFs, this would need to be handled differently based on document structure.
 *
 * @param pageNumber - 1-indexed page number
 * @param spineLength - Total number of spine items (for bounds checking)
 * @returns Spine index (0-indexed) or -1 if out of bounds
 */
export function pageToSpineIndex(pageNumber: number, spineLength: number): number {
  // Page numbers are 1-indexed, spine indices are 0-indexed
  const spineIndex = pageNumber - 1;
  if (spineIndex >= 0 && spineIndex < spineLength) {
    return spineIndex;
  }
  return -1;
}
