import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import esbuildSvelte from "esbuild-svelte";
import sveltePreprocess from "svelte-preprocess";
import fs from "fs";
import path from "path";
import { execSync } from "child_process";

const banner = `/*
Amnesia -

Generated by esbuild
*/
`;

const prod = process.argv[2] === "production";
const skipServer = process.argv.includes("--skip-server");

// Output directory for the plugin
const pluginDir = "temp/vault/.obsidian/plugins/amnesia";

// Ensure output directory exists
if (!fs.existsSync(pluginDir)) {
  fs.mkdirSync(pluginDir, { recursive: true });
}

// Copy WASM file to plugin output directory
const wasmSource = "src/wasm/epub-processor/pkg/epub_processor_bg.wasm";
const wasmDest = path.join(pluginDir, "epub_processor_bg.wasm");

if (fs.existsSync(wasmSource)) {
  fs.copyFileSync(wasmSource, wasmDest);
  console.log(`Copied WASM: ${wasmSource} -> ${wasmDest}`);
}

// =============================================================================
// SERVER BINARY BUNDLING
// =============================================================================

/**
 * Build and bundle the amnesia-server binary
 */
function bundleServerBinary() {
  const serverDir = path.resolve("../amnesia-server");
  const platform = process.platform;
  const binaryName = platform === "win32" ? "amnesia-server.exe" : "amnesia-server";

  // Server output directory within plugin
  const serverOutDir = path.join(pluginDir, "server");
  if (!fs.existsSync(serverOutDir)) {
    fs.mkdirSync(serverOutDir, { recursive: true });
  }

  // Check if server directory exists
  if (!fs.existsSync(serverDir)) {
    console.warn(`âš ï¸  Server directory not found: ${serverDir}`);
    console.warn("   Skipping server build. Server will need to be installed manually.");
    return false;
  }

  // Check if Cargo is available
  try {
    execSync("cargo --version", { stdio: "ignore" });
  } catch {
    console.warn("âš ï¸  Cargo not found. Skipping server build.");
    console.warn("   Install Rust from https://rustup.rs to enable server bundling.");
    return false;
  }

  console.log("\nðŸ“¦ Building amnesia-server...");

  try {
    // Build the server in release mode
    execSync("cargo build --release", {
      cwd: serverDir,
      stdio: "inherit",
    });

    // Find the built binary
    const binarySource = path.join(serverDir, "target", "release", binaryName);
    const binaryDest = path.join(serverOutDir, binaryName);

    if (fs.existsSync(binarySource)) {
      fs.copyFileSync(binarySource, binaryDest);

      // Make binary executable on Unix
      if (platform !== "win32") {
        fs.chmodSync(binaryDest, 0o755);
      }

      const stats = fs.statSync(binaryDest);
      const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
      console.log(`âœ… Server binary bundled: ${binaryDest} (${sizeMB} MB)`);
      return true;
    } else {
      console.error(`âŒ Binary not found at: ${binarySource}`);
      return false;
    }
  } catch (error) {
    console.error("âŒ Server build failed:", error.message);
    return false;
  }
}

// Build server binary for production builds (unless skipped)
if (prod && !skipServer) {
  bundleServerBinary();
} else if (!skipServer) {
  // In dev mode, just copy existing binary if available
  const serverDir = path.resolve("../amnesia-server");
  const platform = process.platform;
  const binaryName = platform === "win32" ? "amnesia-server.exe" : "amnesia-server";

  // Try release first, then debug
  const releaseBinary = path.join(serverDir, "target", "release", binaryName);
  const debugBinary = path.join(serverDir, "target", "debug", binaryName);
  const serverOutDir = path.join(pluginDir, "server");

  let sourceBinary = null;
  if (fs.existsSync(releaseBinary)) {
    sourceBinary = releaseBinary;
  } else if (fs.existsSync(debugBinary)) {
    sourceBinary = debugBinary;
    console.log("âš ï¸  Using debug build of server (run 'cargo build --release' for production)");
  }

  if (sourceBinary) {
    if (!fs.existsSync(serverOutDir)) {
      fs.mkdirSync(serverOutDir, { recursive: true });
    }
    const binaryDest = path.join(serverOutDir, binaryName);
    fs.copyFileSync(sourceBinary, binaryDest);
    if (platform !== "win32") {
      fs.chmodSync(binaryDest, 0o755);
    }
    console.log(`ðŸ“¦ Server binary copied: ${binaryDest}`);
  }
}

// =============================================================================
// MUPDF WORKER BUNDLING
// =============================================================================

// Copy MuPDF WASM file to plugin directory
const mupdfWasmSource = "../../node_modules/.pnpm/mupdf@1.27.0/node_modules/mupdf/dist/mupdf-wasm.wasm";
const mupdfWasmDest = path.join(pluginDir, "mupdf-wasm.wasm");
if (fs.existsSync(mupdfWasmSource)) {
  fs.copyFileSync(mupdfWasmSource, mupdfWasmDest);
  console.log(`Copied MuPDF WASM: ${mupdfWasmSource} -> ${mupdfWasmDest}`);
} else {
  console.warn("âš ï¸  MuPDF WASM file not found at:", mupdfWasmSource);
}

// Build MuPDF worker as separate bundle
console.log("ðŸ“¦ Building MuPDF worker...");
try {
  await esbuild.build({
    entryPoints: ["src/reader/renderer/pdf/mupdf-worker.ts"],
    bundle: true,
    format: "esm", // ESM required for top-level await in mupdf
    target: "esnext", // mupdf uses top-level await
    outfile: path.join(pluginDir, "mupdf-worker.js"),
    minify: prod,
    sourcemap: false,
    // Platform is browser for worker
    platform: "browser",
    // Use browser conditions for package resolution
    conditions: ["browser", "worker"],
    // Mark Node.js modules as external - they will error at runtime but that's OK
    // because mupdf conditionally imports them only in Node.js environment
    external: ["node:fs", "node:path", "fs", "path", "module"],
    // Define to help mupdf detect browser environment
    define: {
      "process.env.NODE_ENV": prod ? '"production"' : '"development"',
    },
    // Banner to set up browser-like environment in worker
    // mupdf checks for Node.js via: typeof process === "object" && process.versions?.node
    banner: {
      js: `
// Shim browser environment for mupdf detection in worker context
// mupdf checks multiple conditions for Node.js detection:
// 1. typeof window === 'undefined'
// 2. typeof process === "object" && process.versions?.node
if (typeof window === 'undefined') {
  globalThis.window = self;
}
// Override process to prevent Node.js detection
globalThis.process = { env: {}, versions: {} };

// Configure mupdf WASM loading - the WASM binary will be provided by the main thread
// The bridge reads the WASM file and passes it via message before loading mupdf
globalThis.$libmupdf_wasm_Module = {
  // wasmBinary will be set by the main thread before mupdf loads
  wasmBinary: null,
  locateFile: function(filename) {
    // This shouldn't be called if wasmBinary is provided, but handle it gracefully
    console.warn('[MuPDF Worker] locateFile called, but wasmBinary should be provided');
    return filename;
  }
};

// Wait for WASM binary from main thread before allowing mupdf to initialize
let wasmBinaryResolve = null;
globalThis.__MUPDF_WASM_READY__ = new Promise(resolve => { wasmBinaryResolve = resolve; });
self.addEventListener('message', function initHandler(event) {
  if (event.data && event.data.type === 'INIT_WASM' && event.data.wasmBinary) {
    globalThis.$libmupdf_wasm_Module.wasmBinary = event.data.wasmBinary;
    wasmBinaryResolve();
    self.removeEventListener('message', initHandler);
  }
}, { once: false });
`,
    },
  });
  console.log("âœ… MuPDF worker built");
} catch (error) {
  console.warn("âš ï¸  MuPDF worker build failed:", error.message);
  console.warn("   WASM PDF rendering will fall back to server-side rendering.");
}

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "pdfjs-dist",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2021",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "temp/vault/.obsidian/plugins/amnesia/main.js",
  plugins: [
    esbuildSvelte({
      compilerOptions: {
        css: true,
      },
      preprocess: sveltePreprocess(),
      filterWarnings: (warning) => {
        // disable a11y warnings
        return !warning.code.startsWith("a11y-");
      },
    }),
  ],
});

const cssContext = await esbuild.context({
  entryPoints: ["src/styles.css"],
  bundle: true,
  outfile: "temp/vault/.obsidian/plugins/amnesia/styles.css",
});

if (prod) {
  await context.rebuild();
  await cssContext.rebuild();
  process.exit(0);
} else {
  await Promise.all([cssContext.watch(), context.watch()]);
}
