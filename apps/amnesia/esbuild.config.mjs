import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import esbuildSvelte from "esbuild-svelte";
import sveltePreprocess from "svelte-preprocess";
import fs from "fs";
import path from "path";
import { execSync } from "child_process";

const banner = `/*
Amnesia -

Generated by esbuild
*/
`;

const prod = process.argv[2] === "production";
const skipServer = process.argv.includes("--skip-server");

// Output directory for the plugin
const pluginDir = "temp/vault/.obsidian/plugins/amnesia";

// Ensure output directory exists
if (!fs.existsSync(pluginDir)) {
  fs.mkdirSync(pluginDir, { recursive: true });
}

// Copy WASM file to plugin output directory
const wasmSource = "src/wasm/epub-processor/pkg/epub_processor_bg.wasm";
const wasmDest = path.join(pluginDir, "epub_processor_bg.wasm");

if (fs.existsSync(wasmSource)) {
  fs.copyFileSync(wasmSource, wasmDest);
  console.log(`Copied WASM: ${wasmSource} -> ${wasmDest}`);
}

// =============================================================================
// SERVER BINARY BUNDLING
// =============================================================================

/**
 * Build and bundle the amnesia-server binary
 */
function bundleServerBinary() {
  const serverDir = path.resolve("../amnesia-server");
  const platform = process.platform;
  const binaryName = platform === "win32" ? "amnesia-server.exe" : "amnesia-server";

  // Server output directory within plugin
  const serverOutDir = path.join(pluginDir, "server");
  if (!fs.existsSync(serverOutDir)) {
    fs.mkdirSync(serverOutDir, { recursive: true });
  }

  // Check if server directory exists
  if (!fs.existsSync(serverDir)) {
    console.warn(`âš ï¸  Server directory not found: ${serverDir}`);
    console.warn("   Skipping server build. Server will need to be installed manually.");
    return false;
  }

  // Check if Cargo is available
  try {
    execSync("cargo --version", { stdio: "ignore" });
  } catch {
    console.warn("âš ï¸  Cargo not found. Skipping server build.");
    console.warn("   Install Rust from https://rustup.rs to enable server bundling.");
    return false;
  }

  console.log("\nðŸ“¦ Building amnesia-server...");

  try {
    // Build the server in release mode
    execSync("cargo build --release", {
      cwd: serverDir,
      stdio: "inherit",
    });

    // Find the built binary
    const binarySource = path.join(serverDir, "target", "release", binaryName);
    const binaryDest = path.join(serverOutDir, binaryName);

    if (fs.existsSync(binarySource)) {
      fs.copyFileSync(binarySource, binaryDest);

      // Make binary executable on Unix
      if (platform !== "win32") {
        fs.chmodSync(binaryDest, 0o755);
      }

      const stats = fs.statSync(binaryDest);
      const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
      console.log(`âœ… Server binary bundled: ${binaryDest} (${sizeMB} MB)`);
      return true;
    } else {
      console.error(`âŒ Binary not found at: ${binarySource}`);
      return false;
    }
  } catch (error) {
    console.error("âŒ Server build failed:", error.message);
    return false;
  }
}

// Build server binary for production builds (unless skipped)
if (prod && !skipServer) {
  bundleServerBinary();
} else if (!skipServer) {
  // In dev mode, just copy existing binary if available
  const serverDir = path.resolve("../amnesia-server");
  const platform = process.platform;
  const binaryName = platform === "win32" ? "amnesia-server.exe" : "amnesia-server";

  // Try release first, then debug
  const releaseBinary = path.join(serverDir, "target", "release", binaryName);
  const debugBinary = path.join(serverDir, "target", "debug", binaryName);
  const serverOutDir = path.join(pluginDir, "server");

  let sourceBinary = null;
  if (fs.existsSync(releaseBinary)) {
    sourceBinary = releaseBinary;
  } else if (fs.existsSync(debugBinary)) {
    sourceBinary = debugBinary;
    console.log("âš ï¸  Using debug build of server (run 'cargo build --release' for production)");
  }

  if (sourceBinary) {
    if (!fs.existsSync(serverOutDir)) {
      fs.mkdirSync(serverOutDir, { recursive: true });
    }
    const binaryDest = path.join(serverOutDir, binaryName);
    fs.copyFileSync(sourceBinary, binaryDest);
    if (platform !== "win32") {
      fs.chmodSync(binaryDest, 0o755);
    }
    console.log(`ðŸ“¦ Server binary copied: ${binaryDest}`);
  }
}

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "pdfjs-dist",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2021",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "temp/vault/.obsidian/plugins/amnesia/main.js",
  plugins: [
    esbuildSvelte({
      compilerOptions: {
        css: true,
      },
      preprocess: sveltePreprocess(),
      filterWarnings: (warning) => {
        // disable a11y warnings
        return !warning.code.startsWith("a11y-");
      },
    }),
  ],
});

const cssContext = await esbuild.context({
  entryPoints: ["src/styles.css"],
  bundle: true,
  outfile: "temp/vault/.obsidian/plugins/amnesia/styles.css",
});

if (prod) {
  await context.rebuild();
  await cssContext.rebuild();
  process.exit(0);
} else {
  await Promise.all([cssContext.watch(), context.watch()]);
}
